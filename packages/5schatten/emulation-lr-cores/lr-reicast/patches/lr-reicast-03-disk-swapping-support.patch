From 73a22d07a1c6583d6e4dd5e9c99e3c6dec365d2a Mon Sep 17 00:00:00 2001
From: Flyinghead <raphael.jean@gmail.com>
Date: Fri, 21 Dec 2018 15:13:25 +0100
Subject: [PATCH] Disc swapping support using libretro disc control interface

---
 core/hw/gdrom/gdromv3.cpp  | 13 ++----
 core/imgread/common.cpp    | 31 +++++---------
 core/libretro/libretro.cpp | 88 +++++++++++++++++++++++++++++++++++++-
 3 files changed, 100 insertions(+), 32 deletions(-)

diff --git a/core/hw/gdrom/gdromv3.cpp b/core/hw/gdrom/gdromv3.cpp
index aeab4f924..a3549bdff 100644
--- a/core/hw/gdrom/gdromv3.cpp
+++ b/core/hw/gdrom/gdromv3.cpp
@@ -1,4 +1,4 @@
-ï»¿/*
+/*
 	gdrom, v3
 	Overly complex implementation of a very ugly device
 */
@@ -562,7 +562,6 @@ void gd_process_spi_cmd()
 
 	case SPI_CD_READ2:
 		printf_spicmd("SPI_CD_READ2\n");
-		printf("GDROM: Unhandled Sega SPI frame: SPI_CD_READ2\n");
 
 		gd_set_state(gds_procpacketdone);
 		break;
@@ -571,7 +570,6 @@ void gd_process_spi_cmd()
 	case SPI_REQ_STAT:
 		{
 			printf_spicmd("SPI_REQ_STAT\n");
-			//printf("GDROM: Unhandled Sega SPI frame: SPI_REQ_STAT\n");
 			u8 stat[10];
 
 			//0  0   0   0   0   STATUS
@@ -601,7 +599,6 @@ void gd_process_spi_cmd()
 
 	case SPI_REQ_ERROR:
 		printf_spicmd("SPI_REQ_ERROR\n");
-		//printf("GDROM: Unhandled Sega SPI frame: SPI_REQ_ERROR\n");
 		
 		u8 resp[10];
 		resp[0]=0xF0;
@@ -630,7 +627,6 @@ void gd_process_spi_cmd()
 
 	case SPI_CD_OPEN:
 		printf_spicmd("SPI_CD_OPEN\n");
-		printf("GDROM: Unhandled Sega SPI frame: SPI_CD_OPEN\n");
 		
 		
 		gd_set_state(gds_procpacketdone);
@@ -639,7 +635,6 @@ void gd_process_spi_cmd()
 	case SPI_CD_PLAY:
 		{
 			printf_spicmd("SPI_CD_PLAY\n");
-			printf("GDROM: Unhandled Sega SPI frame: SPI_CD_PLAY\n");
 			//cdda.CurrAddr.FAD=60000;
 
 			cdda.playing=true;
@@ -681,7 +676,6 @@ void gd_process_spi_cmd()
 	case SPI_CD_SEEK:
 		{
 			printf_spicmd("SPI_CD_SEEK\n");
-			printf("GDROM: Unhandled Sega SPI frame: SPI_CD_SEEK\n");
 
 			SecNumber.Status=GD_PAUSE;
 			cdda.playing=false;
@@ -727,7 +721,6 @@ void gd_process_spi_cmd()
 
 	case SPI_CD_SCAN:
 		printf_spicmd("SPI_CD_SCAN\n");
-		printf("GDROM: Unhandled Sega SPI frame: SPI_CD_SCAN\n");
 		
 
 		gd_set_state(gds_procpacketdone);
@@ -736,7 +729,6 @@ void gd_process_spi_cmd()
 	case SPI_GET_SCD:
 		{
 			printf_spicmd("SPI_GET_SCD\n");
-			//printf("\nGDROM:\tUnhandled Sega SPI frame: SPI_GET_SCD\n");
 
 			u32 format;
 			format=packet_cmd.data_8[1]&0xF;
@@ -747,6 +739,7 @@ void gd_process_spi_cmd()
 			//0 Reserved
 			subc_info[0]=0;
 			//1 Audio status
+#if 0
 			if (SecNumber.Status==GD_STANDBY)
 			{
 				//13h  Audio playback ended normally
@@ -769,7 +762,7 @@ void gd_process_spi_cmd()
 				else
 					subc_info[1]=0x15;//15h	No audio status information
 			}
-			
+#endif
 			subc_info[1]=0x15;
 
 			if (format==0)
diff --git a/core/imgread/common.cpp b/core/imgread/common.cpp
index ea233c15b..2983ebbca 100644
--- a/core/imgread/common.cpp
+++ b/core/imgread/common.cpp
@@ -133,22 +133,19 @@ bool InitDrive_(wchar* fn)
 	//try all drivers
 	disc = OpenDisc(fn);
 
-	if (disc!=0)
+	if (disc != NULL)
 	{
 		printf("gdrom: Opened image \"%s\"\n",fn);
-		NullDriveDiscType=Busy;
-#ifndef NOT_REICAST
-		libCore_gdrom_disc_change();
-#endif
-//		Sleep(400); //busy for a bit // what, really ?
-		return true;
+		NullDriveDiscType = Busy;
 	}
 	else
 	{
 		printf("gdrom: Failed to open image \"%s\"\n",fn);
-		NullDriveDiscType=NoDisk; //no disc :)
+		NullDriveDiscType = NoDisk; //no disc :)
 	}
-	return false;
+	libCore_gdrom_disc_change();
+
+	return disc != NULL;
 }
 
 #ifndef NOT_REICAST
@@ -202,6 +199,10 @@ bool InitDrive(u32 fileflags)
 
 bool DiscSwap(u32 fileflags)
 {
+	// These Additional Sense Codes mean "The lid was closed"
+	sns_asc = 0x28;
+	sns_ascq = 0x00;
+	sns_key = 0x6;
 	if (settings.imgread.LoadDefaultImage)
 	{
 		printf("Loading default image \"%s\"\n",settings.imgread.DefaultImage);
@@ -222,16 +223,10 @@ bool DiscSwap(u32 fileflags)
 	{
 		NullDriveDiscType=Open;
 		gd_setdisc();
-		sns_asc=0x28;
-		sns_ascq=0x00;
-		sns_key=0x6;
 		return true;
 	}
 	else if (gfrv == -1)
 	{
-		sns_asc=0x28;
-		sns_ascq=0x00;
-		sns_key=0x6;
 		return false;
 	}
 
@@ -243,16 +238,10 @@ bool DiscSwap(u32 fileflags)
 		//msgboxf("Selected image failed to load",MBX_ICONERROR);
 		NullDriveDiscType=Open;
 		gd_setdisc();
-		sns_asc=0x28;
-		sns_ascq=0x00;
-		sns_key=0x6;
 		return true;
 	}
 	else
 	{
-		sns_asc=0x28;
-		sns_ascq=0x00;
-		sns_key=0x6;
 		return true;
 	}
 }
diff --git a/core/libretro/libretro.cpp b/core/libretro/libretro.cpp
index f27b41d5a..7624fc1d0 100644
--- a/core/libretro/libretro.cpp
+++ b/core/libretro/libretro.cpp
@@ -21,6 +21,7 @@
 #include "../hw/maple/maple_cfg.h"
 #include "../hw/pvr/spg.h"
 #include "../hw/naomi/naomi_cart.h"
+#include "../imgread/common.h"
 
 #if defined(_XBOX) || defined(_WIN32)
 char slash = '\\';
@@ -127,6 +128,8 @@ extern Renderer* renderer;
 bool rend_single_frame();
 void rend_cancel_emu_wait();
 
+static void init_disk_control_interface(const char *initial_image_path);
+
 static int co_argc;
 static wchar** co_argv;
 
@@ -352,7 +355,7 @@ void retro_set_environment(retro_environment_t cb)
       },
       {
          "reicast_cable_type",
-         "Cable type; TV (RGB)|TV (VBS/Y+S/C)|VGA (RGB)",
+         "Cable type; TV (RGB)|TV (Composite)|VGA (RGB)",
       },
       {
          "reicast_broadcast",
@@ -1671,6 +1674,7 @@ bool retro_load_game(const struct retro_game_info *game)
 		 log_cb(RETRO_LOG_ERROR, "Reicast emulator initialization failed\n");
 	  return false;
    }
+   init_disk_control_interface(game->path);
 
    return true;
 }
@@ -2600,3 +2604,85 @@ void os_DebugBreak(void)
    //exit(-1);
    __builtin_trap();
 }
+
+// Disk swapping
+static struct retro_disk_control_callback retro_disk_control_cb;
+static unsigned disk_index = 0;
+static std::vector<std::string> disk_paths;
+static bool disc_tray_open = false;
+
+static bool retro_set_eject_state(bool ejected)
+{
+   disc_tray_open = ejected;
+
+   return true;
+}
+
+static bool retro_get_eject_state()
+{
+   return disc_tray_open;
+}
+
+static unsigned retro_get_image_index()
+{
+   return disk_index;
+}
+
+static bool retro_set_image_index(unsigned index)
+{
+   settings.imgread.LoadDefaultImage = true;
+   disk_index = index;
+   if (disk_index >= disk_paths.size())
+   {
+	  // No disk in drive
+	  settings.imgread.DefaultImage[0] = '\0';
+	  return true;
+   }
+   strncpy(settings.imgread.DefaultImage, disk_paths[index].c_str(), sizeof(settings.imgread.DefaultImage));
+   settings.imgread.DefaultImage[sizeof(settings.imgread.DefaultImage) - 1] = '\0';
+
+   return DiscSwap();
+}
+
+static unsigned retro_get_num_images()
+{
+   return disk_paths.size();
+}
+
+static bool retro_add_image_index()
+{
+   disk_paths.push_back("");
+
+   return true;
+}
+
+static bool retro_replace_image_index(unsigned index, const struct retro_game_info *info)
+{
+  if (info == nullptr)
+  {
+    if (index < disk_paths.size())
+    {
+      disk_paths.erase(disk_paths.begin() + index);
+      if (disk_index >= index && disk_index > 0)
+        disk_index--;
+    }
+  }
+  else
+    disk_paths[index] = info->path;
+
+  return true;
+}
+
+static void init_disk_control_interface(const char *initial_image_path)
+{
+  retro_disk_control_cb.set_eject_state = retro_set_eject_state;
+  retro_disk_control_cb.get_eject_state = retro_get_eject_state;
+  retro_disk_control_cb.set_image_index = retro_set_image_index;
+  retro_disk_control_cb.get_image_index = retro_get_image_index;
+  retro_disk_control_cb.get_num_images  = retro_get_num_images;
+  retro_disk_control_cb.add_image_index = retro_add_image_index;
+  retro_disk_control_cb.replace_image_index = retro_replace_image_index;
+
+  environ_cb(RETRO_ENVIRONMENT_SET_DISK_CONTROL_INTERFACE, &retro_disk_control_cb);
+  disk_paths.push_back(initial_image_path);
+}
