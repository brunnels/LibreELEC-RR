From 268d0bb8121ad02eed490dcc6d19c1ce33242cb1 Mon Sep 17 00:00:00 2001
From: Flyinghead <raphael.jean@gmail.com>
Date: Fri, 21 Dec 2018 15:11:38 +0100
Subject: [PATCH] GLES2 only supports 16-bit indexes so convert before
 uploading to GPU

---
 core/rend/gles/gldraw.cpp | 26 +++++++++++++++++++-------
 core/rend/gles/gles.cpp   | 25 +++++++++++++++++++++++--
 core/rend/gles/gles.h     |  3 +++
 3 files changed, 45 insertions(+), 9 deletions(-)

diff --git a/core/rend/gles/gldraw.cpp b/core/rend/gles/gldraw.cpp
index 5311d5bff..22e40ad98 100644
--- a/core/rend/gles/gldraw.cpp
+++ b/core/rend/gles/gldraw.cpp
@@ -264,7 +264,8 @@ static void DrawList(const List<PolyParam>& gply, int first, int count)
       if (params->count>2) /* this actually happens for some games. No idea why .. */
       {
          SetGPState<Type,SortingEnabled>(params, 0);
-         glDrawElements(GL_TRIANGLE_STRIP, params->count, GL_UNSIGNED_INT, (GLvoid*)(sizeof(u32) * params->first));
+         glDrawElements(GL_TRIANGLE_STRIP, params->count, gl.index_type,
+         					(GLvoid*)(gl.get_index_size() * params->first));
       }
 
       params++;
@@ -591,7 +592,19 @@ void GenSorted(int first, int count)
    {
       /* Bind and upload sorted index buffer */
       glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, gl.vbo.idxs2);
-      glBufferData(GL_ELEMENT_ARRAY_BUFFER, vidx_sort.size() * sizeof(u32), &vidx_sort[0], GL_STREAM_DRAW);
+      if (gl.index_type == GL_UNSIGNED_SHORT)
+      {
+    	 static bool overrun;
+    	 static List<u16> short_vidx;
+    	 if (short_vidx.daty != NULL)
+    		short_vidx.Free();
+    	 short_vidx.Init(vidx_sort.size(), &overrun, NULL);
+    	 for (int i = 0; i < vidx_sort.size(); i++)
+    		*(short_vidx.Append()) = vidx_sort[i];
+    	 glBufferData(GL_ELEMENT_ARRAY_BUFFER, short_vidx.bytes(), short_vidx.head(), GL_STREAM_DRAW);
+      }
+      else
+    	 glBufferData(GL_ELEMENT_ARRAY_BUFFER, vidx_sort.size() * sizeof(u32), &vidx_sort[0], GL_STREAM_DRAW);
    }
 }
 
@@ -615,7 +628,8 @@ void DrawSorted(u32 count)
             if (pidx_sort[p].count>2) //this actually happens for some games. No idea why ..
             {
                SetGPState<ListType_Translucent, true>(params, 0);
-               glDrawElements(GL_TRIANGLES, pidx_sort[p].count, GL_UNSIGNED_INT, (GLvoid*)(sizeof(u32) * pidx_sort[p].first));
+               glDrawElements(GL_TRIANGLES, pidx_sort[p].count, gl.index_type,
+            		 (GLvoid*)(gl.get_index_size() * pidx_sort[p].first));
             }
             params++;
          }
@@ -644,7 +658,8 @@ void DrawSorted(u32 count)
 
 						SetCull(params->isp.CullMode ^ gcflip);
 
-						glDrawElements(GL_TRIANGLES, pidx_sort[p].count, GL_UNSIGNED_INT, (GLvoid*)(sizeof(u32) * pidx_sort[p].first));
+						glDrawElements(GL_TRIANGLES, pidx_sort[p].count, gl.index_type,
+							  (GLvoid*)(gl.get_index_size() * pidx_sort[p].first));
 					}
 				}
 				glcache.StencilMask(0xFF);
@@ -973,9 +988,6 @@ void DrawFramebuffer(float w, float h)
 	glDrawElements(GL_TRIANGLE_STRIP, 5, GL_UNSIGNED_SHORT, (void *)0);
  	glcache.DeleteTextures(1, &fbTextureId);
 	fbTextureId = 0;
-
-   glBufferData(GL_ARRAY_BUFFER, pvrrc.verts.bytes(), pvrrc.verts.head(), GL_STREAM_DRAW);
-	glBufferData(GL_ELEMENT_ARRAY_BUFFER, pvrrc.idx.bytes(), pvrrc.idx.head(), GL_STREAM_DRAW);
 }
 
 void UpdateVmuTexture(int vmu_screen_number)
diff --git a/core/rend/gles/gles.cpp b/core/rend/gles/gles.cpp
index 7be2ff2ed..56d4e9692 100644
--- a/core/rend/gles/gles.cpp
+++ b/core/rend/gles/gles.cpp
@@ -353,6 +353,7 @@ int GetProgramID(
 void findGLVersion()
 {
    gl.stencil_present = true;
+   gl.index_type = GL_UNSIGNED_INT;
 
    while (true)
       if (glGetError() == GL_NO_ERROR)
@@ -373,6 +374,7 @@ void findGLVersion()
       {
          gl.gl_version = "GLES2";
          gl.glsl_version_header = "";
+         gl.index_type = GL_UNSIGNED_SHORT;
       }
       gl.fog_image_format = GL_ALPHA;
 
@@ -747,6 +749,23 @@ void vertex_buffer_unmap(void)
 void DoCleanup() {
 }
 
+static void upload_vertex_indices()
+{
+	if (gl.index_type == GL_UNSIGNED_SHORT)
+	{
+		static bool overrun;
+		static List<u16> short_idx;
+		if (short_idx.daty != NULL)
+			short_idx.Free();
+		short_idx.Init(pvrrc.idx.used(), &overrun, NULL);
+		for (u32 *p = pvrrc.idx.head(); p < pvrrc.idx.LastPtr(0); p++)
+			*(short_idx.Append()) = *p;
+		glBufferData(GL_ELEMENT_ARRAY_BUFFER, short_idx.bytes(), short_idx.head(), GL_STREAM_DRAW);
+	}
+	else
+		glBufferData(GL_ELEMENT_ARRAY_BUFFER,pvrrc.idx.bytes(),pvrrc.idx.head(),GL_STREAM_DRAW);
+}
+
 static bool RenderFrame(void)
 {
    int vmu_screen_number = 0 ;
@@ -974,7 +993,7 @@ static bool RenderFrame(void)
 
       glBufferData(GL_ARRAY_BUFFER,pvrrc.verts.bytes(),pvrrc.verts.head(),GL_STREAM_DRAW); glCheck();
 
-      glBufferData(GL_ELEMENT_ARRAY_BUFFER,pvrrc.idx.bytes(),pvrrc.idx.head(),GL_STREAM_DRAW); glCheck();
+      upload_vertex_indices();
 
       //Modvol VBO
       if (pvrrc.modtrig.used())
@@ -1040,7 +1059,9 @@ static bool RenderFrame(void)
    else
    {
       glcache.ClearColor(0.f, 0.f, 0.f, 0.f);
-		glClear(GL_COLOR_BUFFER_BIT);
+      glClear(GL_COLOR_BUFFER_BIT);
+      glBindBuffer(GL_ARRAY_BUFFER, gl.vbo.geometry); glCheck();
+      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, gl.vbo.idxs); glCheck();
       DrawFramebuffer(dc_width, dc_height);
    }
 
diff --git a/core/rend/gles/gles.h b/core/rend/gles/gles.h
index ac1512410..57edab6a5 100644
--- a/core/rend/gles/gles.h
+++ b/core/rend/gles/gles.h
@@ -67,7 +67,10 @@ struct gl_ctx
    int gl_major;
    bool is_gles;
    GLuint fog_image_format;
+   GLenum index_type;
    bool stencil_present;
+
+   size_t get_index_size() { return index_type == GL_UNSIGNED_INT ? sizeof(u32) : sizeof(u16); }
 };
 
 GLuint gl_GetTexture(TSP tsp,TCW tcw);
